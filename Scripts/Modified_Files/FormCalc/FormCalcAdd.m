(* ::Package:: *)

(*
This package defines additional functions which can for example calculate spin
correlated amplitudes for the POWHEG-BOX-V2. FormCalc V9.4 or higher is required.
Please copy FormCalcAdd.m and SpinCorrelatedSum.frm to your
local FormCalc installation:
$<FORMCALC-PATH>/FormCalcAdd.m
$<FORMCALC-PATH>/FormCalc/SpinCorrelatedSum.frm

Copied and modified on the basis of FormCalc94.m with thanks to Thomas 
Hahn.
*)

BeginPackage["FormCalc`"]

(*Global variables*)
{FormAddTAG,FormAddAmpOut,FormAddAmpMuNuOut,FormAddDefInd,FormAddDefVarsOut,FormAddVarsSfe6,FormAddUlistSfe6,
  FormAddVarsSfe6c,FormAddUlistSfe6c,FormAddVarsSfe6Sfe6c,FormAddUlistSfe6Sfe6c,FormAddVars0,FormAddUlist0,dcmplx}

SpinCorrelatedSum::usage =
"SpinCorrelatedSum[expr] sums expr over the polarizations of external
gauge bosons but leaves the two lorentz indices (al, be) uncontracted.
See arXiv:1002.2581 page 9 for more details.
It is assumed that expr is the squared amplitude into
which the helicity matrix elements have already been inserted. 
Alternatively, expr may also be given as an amplitude directly, in which
case SpinCorrelatedSum will first invoke SquaredME and HelicityME (with
Hel[_] = 0) to obtain the squared amplitude."

PolarizationSum2::usage =
"PolarizationSum2[expr] sums expr over the polarizations of external
gauge bosons.  It is assumed that expr is the squared amplitude into
which the helicity matrix elements have already been inserted. 
Alternatively, expr may also be given as an amplitude directly, in which
case PolarizationSum will first invoke SquaredME and HelicityME (with
Hel[_] = 0) to obtain the squared amplitude."

ExtendRuleByConjugate::usage = 
"ExtendRuleByConjugate[rule] conjugates the substitution rule generated
by FormCalc and appends the result to rule."

ConjugateRule::usage = 
"ConjugateRule[rule] conjugates the substition rule generated by 
FormCalc. The expression ConjugateRule[{Sub1[ind]->f[ind]}] gives
{Conjugate[Sub1[indc]]->Conjugate[f[indc]]}."

RemoveUnusedAbbr::usage =
"RemovedUnusedAbbr[expr, abbr] looks if the abbreviation abbr is part of 
the expression and gives it back."

LoopRemove::usage =
"LoopRemove[expr, abbr] works like RemovedUnusedAbbr but looks more
aggressively into deeper levels of the expression. Calling this 
function may take a while to finish."

SubstitutionHead::usage =
"SubstitutionHead[a->b] gives back a."

SubstitutionTail::usage =
"SubstitutionTail[a->b] gives back b."

Component::usage =
"Component[FeynAmpList,n] gives back the n-th part of a FeynAmpList."

getProcess::usage = 
"getProcess[FeynAmpList] writes out the invoked process of the FeynAmpList."

GetVariables::usage =
"GetVariables[{a->1,b->2,c->3}] gives the list {a,b,c}"

GetValues::usage =
"GetValues[{a->1,b->2,c->3}] gives the list {1,2,3}"

GetArgument::usage = 
"GetArgument[f[x,y]] evaluates to {x,y}."

CountArgs::usage = 
"CountArgs[f[x1,x2,x3]] counts the arguments of a function f."

AmpSimplify::usage = 
"This functions compresses amplitudes with similar summation into a single expression.
Not using this function if the summation of an amplitude was modified, 
can cause FormCalc to write multiple times into the same file"

WriteStringn::usage =
"Write string and break line automatically."

UniqueName::usage = 
"Generate unique variable names (even for functions)."

AssignValues::usage = 
"Assign values to a list of names, AssignValues[{a,b},{1,2}] sets a=1 and b=2."

GetElementsWithArgs::usage = 
"GetElementsWithArgs[list_List,arg__] returns all elements of a list with the specified arguments."

GetElementsWithoutArgs::usage = 
"GetElementsWithoutArgs[list_List,arg__] returns all elements of a list with none of the specified arguments."

Subsetn::usage = 
"Subsetn[list_List,n_Integer] gives all subsets of n elements with overhang."

WriteMatrixElement::usage = 
"WriteMatrixElement[name_String,amp_,abbr_List,indices_List,functions_List,nlegs_Integer] 
writes out the amplitude given in variable <amp> with abbreviations <abbr>. All open 
indices must be defined in the list <indices>. The substitution list <functions> define which function names should be replaced.
<nlegs> is the number of legs of the diagrams."

WriteSpinCorrelatedMatrixElement::usage = 
"WriteSpinCorrelatedMatrixElement[name_String,ampmunu_,abbr_List,indices_List,functions_List,nlegs_Integer,spinleg_Integer] 
writes out the spin correlated amplitude given in variable <ampmunu> with abbreviations <abbr>. All open 
indices must be defined in the list <indices>. The substitution list <functions> define which function names should be replaced.
<nlegs> is the number of legs of the diagrams, <spinleg> is the number of the leg, that was used to calculate the spin correlation."

Cmplx::usage = 
"Wraps every real variable with a function dcmplx[] which allows fortran to interpret the real variable as a complex one.
Example: Cmplx[a+I b] yields a+I b where as Cmplx[a] gives dcmplx[a]. The variables a and b must be defined as reals:
$Assumptions=a\[Element]Reals&&b\[Element]Reals or use $Assumptions=_\[Element]Reals to define every occuring variable as real. 
Delete the assumptions with $Assumptions=True."

DenCoefficient::usage = 
"DenCoefficient[a/(b+c),(b+c)] yields a. Useful to extract coeffiecients of a factorial expression."

Begin["`Private`"]

Print[];
Print["FormCalcAdd 1.2.3 (23 Jan 2016)"];
Print["by Matthias Kesenheimer, with thanks to Thomas Hahn"];


(*helpful function to extract parts of a Feynman amplitude*)
Component[FeynAmpList_,n_]:=Replace[FeynAmpList,FeynAmpList[_][x__]:>{x}][[n]]
getProcess[FeynAmpList[proc1_ -> proc2_,___][amp__]]:=proc2

SubstitutionHead[a_->b_]:=a
SubstitutionTail[a_->b_]:=b


(*conjugate subexpressions*)
ConjugateVariable[a_Symbol]:=ToExpression[ToString[a]<>"c"]/;StringTake[ToString[a],-1]=!="c"
ConjugateVariable[a_Symbol]:=ToExpression[StringTake[ToString[a],StringLength[ToString[a]]-1]]/;StringTake[ToString[a],-1]==="c"
GetArgument[a__Symbol]:=Null
GetArgument[f_[a__Symbol]]:={a}
GetArgument[Conjugate[f_[a__Symbol]]]:={a}
ListToElements[list1_->list2_]:=Table[list1[[i]]->list2[[i]],{i,1,Length[list1]}]/.List->Sequence
ConjugateRuleElement[a_->b_]:=Sequence[Conjugate[a]->Conjugate[b]]/.{ListToElements[GetArgument[a]->Map[ConjugateVariable,GetArgument[a]]]}
ConjugateRule[rule_]:=Map[ConjugateRuleElement,rule]
ExtendRuleByConjugate[rule_]:=Join[rule,ConjugateRule[rule]]


(* performing the spin correlated sum analytically *)
Options[SpinCorrelatedSum] = {
  SumLegs -> All,
  Dimension -> 4,
  GaugeTerms -> True,
  NoBracket -> NoBracket,
  EditCode -> False,
  RetainFile -> False }

SpinCorrelatedSum::noprocess = "No process defined so far.  \
SpinCorrelatedSum works only after DeclareProcess or CalcFeynAmp."

SpinCorrelatedSum::incomp = "SpinCorrelatedSum used on an amplitude \
other than the last one set up by DeclareProcess or CalcFeynAmp."

SpinCorrelatedSum[amp:Amp[_][___].., opt___?OptionQ] :=
Block[ {Hel},
  ChkProc[{amp, CurrentProc}, SpinCorrelatedSum, Abort[]];
  _Hel = 0;
  SpinCorrelatedSum[
    SquaredME[amp] /.
      ($HelicityME = HelicityME[amp, FilterOpt[HelicityME, opt]]) /.
      ($ColourME = ColourME[amp, FilterOpt[ColourME, opt]]),
    opt ]
]

SpinCorrelatedSum[expr_, opt___?OptionQ] :=
Block[ {slegs, dim, gauge, nobrk, edit, retain,
fullexpr, lor, indices, legs, masses, etasubst, vars, hh, abbr,
subexpr, subexprc, rules},

  If[ CurrentProc === {},
    Message[SpinCorrelatedSum::noprocess];
    Abort[] ];
    
  {slegs, dim, gauge, nobrk, edit, retain} =
    ParseOpt[SpinCorrelatedSum, opt] /. Options[CalcFeynAmp];

  abbr = OptimizeAbbr[Abbr[]];
  subexpr = OptimizeAbbr[Subexpr[]];
  subexprc = ConjugateRule[subexpr];
  rules = Dispatch[Join[abbr, subexpr, subexprc]];
    
  fullexpr = expr //. rules /. FinalFormRules;
  lor = Cases[fullexpr, _Lor, Infinity] //Union;
  indices = FormIndices[[ Level[lor, {2}] ]];
  fullexpr = fullexpr /. Thread[lor -> indices];

  legs = Cases[fullexpr, Alt[ExtWF][i_] :> i,
    Infinity, Heads -> True] //Union;
  If[ slegs =!= All, legs = Intersection[legs, Flatten[{slegs}]] ];
  masses = Masses[CurrentProc][[legs]];

  fullexpr = fullexpr /. s -> e /. Reverse/@ FromFormRules /.
    {Eps -> "e_", MetricTensor -> "d_", Pair -> Dot} /.
    NoExpandRule /.
    FinalFormRules;

  etasubst = Block[{dv = DownValues[eta], eta},
    Cases[dv, _[_[lhs_], rhs_] :> (lhs -> rhs)] /. Reverse/@ FromFormRules];

  dim = If[dim === 0, D, 4];
  vars = FormVars[dim, {fullexpr, masses}, indices];

  hh = OpenForm["fc-spin-"];
  WriteString[hh, "\
#define Dim \"", ToString[dim], "\"\n\
#define GaugeTerms \"" <> ToString[gauge] <> "\"\n\
#define FermionChains \"None\"\n\n" <>
    vars[[1]] <> "\n\
#procedure EtaSubst\n" <>
    FormId[etasubst] <> "\
#endprocedure\n" <>
    FormProcs <>
    FormConst[vars, nobrk] <>
    FormCode["Common.frm"] <>
    FormCode["SpinCorrelatedSum.frm"]];

  Write[hh, "L SquaredME = ", fullexpr, ";"];

  (*
  WriteString[hh,
    "\n#call Prepare\n" <>
    MapThread[{"\n#call SpinCorrSum(", ToString[#1], ", ", ToForm[#2], ", ",
        ToString[If[FreeQ[fullexpr, (z | zc)[#1]], dim, Dminus4]], ")"}&,
      {legs, masses}] <>
    "\n\n#call ReplaceOpenLorentzIndices\n\n\n#call Emit\n"];
    *)
  WriteString[hh,
    "\n#call Prepare\n" <>
    MapThread[{"\n#call SpinCorrSum(", ToString[#1], ", ", ToForm[#2], ", ",
        ToString[If[FreeQ[fullexpr, (z | zc)[#1]], dim, Dminus4]], ")"}&,
      {legs, masses}] <>
    "\n\n#call ReplaceOpenLorentzIndices\n\n" <>
    MapThread[{"\n#call Emit(", ToForm[#], ")"}&,{masses}] <> "\n"
    ];
  Close[hh];

  nobrk = Alt[nobrk];	(* for DotSimplify *)
  FormPre[fullexpr];

  Plus@@ FormOutput[][edit, retain][[1]]
]


(* Matthias Kesenheimer: The function PolarizationSum of FormCalc does 
not evaluate large expressions correctly. There are still polarization 
vectors in the final result left over. To circumvent this, we have to 
apply the additional conjugated subexpressions to obtain the full 
expression before evaluating it with form. *)
(* performing the polarization sum analytically *)
Options[PolarizationSum2] = {
  SumLegs -> All,
  Dimension -> 4,
  GaugeTerms -> True,
  NoBracket -> NoBracket,
  EditCode -> False,
  RetainFile -> False }

PolarizationSum2::noprocess = "No process defined so far.  \
PolarizationSum2 works only after DeclareProcess or CalcFeynAmp."

PolarizationSum2::incomp = "PolarizationSum2 used on an amplitude \
other than the last one set up by DeclareProcess or CalcFeynAmp."

PolarizationSum2[amp:Amp[_][___].., opt___?OptionQ] :=
Block[ {Hel},
  ChkProc[{amp, CurrentProc}, PolarizationSum2, Abort[]];
  _Hel = 0;
  PolarizationSum2[
    SquaredME[amp] /.
      ($HelicityME = HelicityME[amp, FilterOpt[HelicityME, opt]]) /.
      ($ColourME = ColourME[amp, FilterOpt[ColourME, opt]]),
    opt ]
]

PolarizationSum2[expr_, opt___?OptionQ] :=
Block[ {slegs, dim, gauge, nobrk, edit, retain,
fullexpr, lor, indices, legs, masses, etasubst, vars, hh, abbr, 
subexpr, subexprc, rules},

  If[ CurrentProc === {},
    Message[PolarizationSum2::noprocess];
    Abort[] ];

  {slegs, dim, gauge, nobrk, edit, retain} =
    ParseOpt[PolarizationSum2, opt] /. Options[CalcFeynAmp];

  abbr = OptimizeAbbr[Abbr[]];
  subexpr = OptimizeAbbr[Subexpr[]];
  subexprc = ConjugateRule[subexpr];
  rules = Dispatch[Join[abbr, subexpr, subexprc]];

  (* MK: apply the conjugated subexpressions as well *)
  fullexpr = expr //. rules /. FinalFormRules;
  lor = Cases[fullexpr, _Lor, Infinity] //Union;
  indices = FormIndices[[ Level[lor, {2}] ]];
  fullexpr = fullexpr /. Thread[lor -> indices];

  legs = Cases[fullexpr, Alt[ExtWF][i_] :> i,
    Infinity, Heads -> True] //Union;
  If[ slegs =!= All, legs = Intersection[legs, Flatten[{slegs}]] ];
  masses = Masses[CurrentProc][[legs]];

  fullexpr = fullexpr /. s -> e /. Reverse/@ FromFormRules /.
    {Eps -> "e_", MetricTensor -> "d_", Pair -> Dot} /.
    NoExpandRule /.
    FinalFormRules;

  etasubst = Block[{dv = DownValues[eta], eta},
    Cases[dv, _[_[lhs_], rhs_] :> (lhs -> rhs)] /. Reverse/@ FromFormRules];

  dim = If[dim === 0, D, 4];
  vars = FormVars[dim, {fullexpr, masses}, indices];

  hh = OpenForm["fc-pol-"];
  WriteString[hh, "\
#define Dim \"", ToString[dim], "\"\n\
#define GaugeTerms \"" <> ToString[gauge] <> "\"\n\
#define FermionChains \"None\"\n\n" <>
    vars[[1]] <> "\n\
#procedure EtaSubst\n" <>
    FormId[etasubst] <> "\
#endprocedure\n" <>
    FormProcs <>
    FormConst[vars, nobrk] <>
    FormCode["Common.frm"] <>
    FormCode["PolarizationSum.frm"]];

  Write[hh, "L SquaredME = ", fullexpr, ";"];

  WriteString[hh,
    "\n#call Prepare\n" <>
    MapThread[{"\n#call PolSum(", ToString[#1], ", ", ToForm[#2], ", ",
        ToString[If[FreeQ[fullexpr, (z | zc)[#1]], dim, Dminus4]], ")"}&,
      {legs, masses}] <>
    "\n\n#call Emit\n"];
  Close[hh];

  nobrk = Alt[nobrk];   (* for DotSimplify *)
  FormPre[fullexpr];

  Plus@@ FormOutput[][edit, retain][[1]]
]


(*Simplify Abbreviations and Subexpression*)
GetVariables[abbr_List]:=Map[SubstitutionHead,abbr]
GetValues[abbr_List]:=Map[SubstitutionTail,abbr]
PartQ[expr_,var_]:=!FreeQ[expr,var]
(*PartQ[expr_,varlist_List]:=Map[!FreeQ[expr,#]&,GetVariables[varlist]]*)
CheckAbbr[expr_,subst_]:=Sequence[]/;!PartQ[expr,SubstitutionHead[subst]]
CheckAbbr[expr_,subst_]:=subst/;PartQ[expr,SubstitutionHead[subst]]
RemoveUnusedAbbr[expr_,abbr_]:=OnePassOrder[Map[CheckAbbr[expr,#]&,abbr]]

(*apply the function RemoveUnusedAbbr again and again and look for 
more abbreviations that we need*)
LoopRemove[expr_,abbr_]:=Block[{oldrule,newrule,newexpr},
  oldrule={};
  newrule=RemoveUnusedAbbr[expr,abbr];
  Print["found "<>ToString[Length[newrule]]<>" new rule(s)..."];
  While[And[Length[newrule]!=0,Length[oldrule]<=Length[abbr]],
    newexpr=expr//.Dispatch[(oldrule=OnePassOrder[Join[oldrule,newrule]])];
    newrule=RemoveUnusedAbbr[newexpr,abbr];
    Print["found "<>ToString[Length[newrule]]<>" new rule(s)..."];
  ];
  Print["found a total of "<>ToString[Length[oldrule]]<>" substitution(s)."];
  oldrule
]


SetAttributes[CountArgs,{(*HoldAll,*)Listable}];
CountArgs[f_Symbol]:=With[{dv=DownValues[f]},CountArgs[dv]];
CountArgs[Verbatim[HoldPattern][HoldPattern[f_Symbol[args___]]]:>_]:=CountArgs[f[args]];
CountArgs[f_[Except[_Optional|_OptionsPattern|Verbatim[Pattern][_,_OptionsPattern]],rest___]]:={1,0,0}+CountArgs[f[rest]];
CountArgs[f_[o__Optional,rest___]]:={0,Length[HoldComplete[o]],0}+CountArgs[f[rest]];
CountArgs[f_[_OptionsPattern|Verbatim[Pattern][_,_OptionsPattern]]]:={0,0,1};
CountArgs[f_[]]:={0,0,0};


(*Modifying the On-Shell Amplitudes makes it necessary to rearrange the FormCalc Amplitudes.*)
(*This functions compresses amplitudes with similar summation into a single expression.*)
(*Not using this function if the summation of an amplitude was modified, can cause FormCalc to write multiple times into the same file.*)
Clear[AmpSimplify,EvaluateExpr]
SetAttributes[EvaluateExpr,Orderless];
SetAttributes[AmpSimplify,Orderless];
EvaluateExpr[(amp1_)expr1_,(amp2_)expr2_,x___]:=Sequence[{amp1+amp2,expr1},x]/;expr1===expr2
EvaluateExpr[(amp1_)expr1_,(amp2_)expr2_,x___]:=Sequence[{amp1,expr1},{amp2,expr2},x]/;expr1=!=expr2
AmpSimplify[famp_[process_][amp___]]:=Times@@@famp[process][EvaluateExpr[amp]]

(*Test*)
(*AmpSimplify[Amp[F1][(2+a[i])SumOver[i,2,External],(r*q+b[i])SumOver[i,2,External]]]
AmpSimplify[Amp[F1][(2+a[i])SumOver[i,2,External],(r*q+b[i])SumOver[i,2,External],(c[j]+c[t])SumOver[j,2,External]]]
AmpSimplify[Amp[F1][(2+a[i])SumOver[i,2,External],(c[j]+c[t])SumOver[j,2,External],(r*q+b[i])SumOver[i,2,External]]]
AmpSimplify[Amp[F1][(2+a[i])SumOver[i,2,External],(c[j]+c[t])SumOver[j,2,External],(r*q+b[k])SumOver[k,2,External]]]
AmpSimplify[Amp[F1][(2+a[i])SumOver[i,2,External],(c[j]+c[t])SumOver[j,2,External],(r*q+b[k])SumOver[k,2,External],d[k]SumOver[k,2,External]]]*)


Clear[getName,Cmplx,isComplex]
getName[var_]:=If[Head[var]===Symbol,ToString[var],ToString[Head[var]]]
isComplex[var_]:=If[StringLength[getName[var]]>1,StringTake[getName[var],-1]=="C"||StringTake[getName[var],-1]=="c",False]
Cmplx[a_]:=a
Cmplx[a_]:=a/;isComplex[a]
Cmplx[a_]:=dcmplx[a]/;Simplify[Im[a]==0]

(*Test*)
(*
$Assumptions=_\[Element]Reals;
Cmplx[a]
Cmplx[a+I b]
Cmplx[MZC]
Cmplx[MfC[1,2]]
$Assumptions=True;
*)


(*break line automatically*)
WriteStringn[strm_,str_]:=WriteString[strm,str<>"\n"]


(*Generate unique variable names (even for functions)*)
UniqueName[var_Symbol]:=Unique[var]
UniqueName[var_[arg__]]:=Unique[var][arg]


(*assign values to a list of names*)
AssignValues[ulist_List,val_List]:=MapThread[Set[#1,#2]&,{ulist,val}]//Quiet;


(*Extract only the elements of list with given arguments*)
CheckArgs[expr_]:=False
CheckArgs[expr_,arg__]:=Map[!FreeQ[GetArgument[expr],#]&,Permutations[{arg}]]/.List->Or
FreeArgs[expr_,arg__]:=Map[!CheckArgs[expr,#/.List->Sequence]&,Subsets[{arg}]]/.List->And
ExprWithArgs[expr_,arg__]:=Sequence[]
ExprWithArgs[expr_,arg__]:=expr/;CheckArgs[expr,arg]
ExprWithoutArgs[expr_,arg__]:=Sequence[]
ExprWithoutArgs[expr_,arg__]:=expr/;FreeArgs[expr,arg]
GetElementsWithArgs[list_List,arg__]:=Map[ExprWithArgs[#,arg]&,list]
GetElementsWithoutArgs[list_List,arg__]:=Map[ExprWithoutArgs[#,arg]&,list]


(*Subset of n elements with overhang*)
Subsetn[list_List,n_Integer]:=Block[{subs},Join[subs=Partition[list,n],{Complement[list,Flatten[subs]]}]]/.{}->Sequence[]


(*TODO: this is not the final version! \[Rule] more generalization needed!*)
WriteMatrixElement[name_String,amp_,abbr_List,indices_List,functions_List,nlegs_Integer]:=Block[
  {strm,defvars,i,Sfe6,Sfe6c,vars,ulist},

  Clear[FormAddTAG,FormAddAmpOut,FormAddAmpMuNuOut,FormAddDefInd,FormAddDefVarsOut,FormAddVarsSfe6,FormAddUlistSfe6,
        FormAddVarsSfe6c,FormAddUlistSfe6c,FormAddVarsSfe6Sfe6c,FormAddUlistSfe6Sfe6c,FormAddVars0,FormAddUlist0];

  (*generate fortran code*)
  strm = OpenFortran[name<>".mf"];
  WriteStringn[strm, "subroutine "<>name<>"(p,amp)"];
  WriteStringn[strm, "implicit none"];
  WriteStringn[strm, "#include \"PhysPars.h\""];
  WriteStringn[strm, "#include \"pwhg_math.h\""];
  WriteStringn[strm, "double precision p(0:3,"<>ToString[nlegs]<>")"];
  WriteStringn[strm, "double precision amp"];
  For[i=1,i<=nlegs,i++,
    WriteStringn[strm, "double precision k"<>ToString[i]<>"(0:3)"];
  ];
  If[nlegs==4,
    WriteStringn[strm, "double precision S, T, U"];
  ];
  If[nlegs==5,
    WriteStringn[strm, "double precision S, T, U, S34, T14, T24"];
  ];
  
  FormAddDefInd = Join[GetVariables[indices],{FormAddTAG}];
  WriteStringn[strm, "integer <* FormAddDefInd *>"];

  (*define functions*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "double precision Epsilon, DotP, Den"];
  WriteStringn[strm, "double precision momsq, momsum2sq, momsum3sq"];
  WriteStringn[strm, "external Epsilon, DotP, Den"];
  WriteStringn[strm, "external momsq, momsum2sq, momsum3sq"];

  (*define local variables*)
  WriteStringn[strm, ""];
  defvars=Map[Join[#,{FormAddTAG}]&,Subsetn[GetVariables[abbr]/.indices,4]];
  For[i=1,i<=Length[defvars],i++,
    FormAddDefVarsOut[i]=defvars[[i]];
    WriteStringn[strm, "double precision <* FormAddDefVarsOut["<>ToString[i]<>"] *>"];
  ];

  (*reset*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "amp = 0D0"];

  (*Momenta and Mandelstams*)
  WriteStringn[strm, ""];
  For[i=1,i<=nlegs,i++,
    WriteStringn[strm, "k"<>ToString[i]<>"(:) = p(:,"<>ToString[i]<>")"];
  ];
  WriteStringn[strm, "S   = momsum2sq(k1(:), k2(:))"];
  WriteStringn[strm, "T   = momsum2sq(k1(:),-k3(:))"];
  WriteStringn[strm, "U   = momsum2sq(k2(:),-k3(:))"];
  If[nlegs==5,
    WriteStringn[strm, "S34 = momsum2sq(k3(:), k4(:))"];
    WriteStringn[strm, "T14 = momsum2sq(k1(:),-k4(:))"];
    WriteStringn[strm, "T24 = momsum2sq(k2(:),-k3(:))"];
  ];

  (*calculate abbreviations*)
  vars=GetVariables[abbr];
  ulist=Map[UniqueName,vars];

  FormAddVarsSfe6=GetElementsWithArgs[vars,Sfe6];
  FormAddUlistSfe6=GetElementsWithArgs[ulist,Sfe6];
  FormAddVarsSfe6c=GetElementsWithArgs[vars,Sfe6c];
  FormAddUlistSfe6c=GetElementsWithArgs[ulist,Sfe6c];
  FormAddVarsSfe6Sfe6c=GetElementsWithArgs[vars,Sfe6,Sfe6c];
  FormAddUlistSfe6Sfe6c=GetElementsWithArgs[ulist,Sfe6,Sfe6c];
  FormAddVars0=GetElementsWithoutArgs[vars,Sfe6c,Sfe6];
  FormAddUlist0=GetElementsWithoutArgs[ulist,Sfe6c,Sfe6];

  WriteStringn[strm, ""];
  MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVars0,FormAddUlist0}];

  If[Length[FormAddVarsSfe6]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6,FormAddUlistSfe6}];
    WriteStringn[strm, "enddo"];
  ];

  If[Length[FormAddVarsSfe6c]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6c=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6c,FormAddUlistSfe6c}];
    WriteStringn[strm, "enddo"];
  ];

  If[Length[FormAddVarsSfe6Sfe6c]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6=1,2"];
    WriteStringn[strm, "do Sfe6c=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6Sfe6c,FormAddUlistSfe6Sfe6c}];
    WriteStringn[strm, "enddo"];
    WriteStringn[strm, "enddo"];
  ];

  (*write Matrix element*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "amp = <* FormAddAmpOut *>"];

  WriteStringn[strm, ""];
  WriteStringn[strm, "end"];
  Close[strm];

  (*substitute wildcards*)
  AssignValues[ulist,GetValues[abbr]/.functions];
  FormAddAmpOut=amp/.functions;
  (*FileTemplateApply[FileTemplate[ame<>".mf"],name<>".f"]*)
  Splice[name<>".mf", PageWidth -> 72];

  (*finalize the output, remove the Function "List(...)" that is wrapped around the variables*)
  strm = OpenWrite["finalize.sh"];
  WriteStringn[strm, "#!/bin/bash"];
  WriteStringn[strm, "gsed -i -e s/List\(//g "<>name<>".f"];
  WriteStringn[strm, "gsed -i -e s/,FormAddTAG\)//g "<>name<>".f"];
  WriteStringn[strm, "gsed -i -e 's/\\t/      /g' "<>name<>".f"];
  WriteStringn[strm, "mv "<>name<>".f "<>name<>".F"];
  Close[strm];
  <<"!chmod +x finalize.sh";
  <<"!./finalize.sh";
  <<"!rm *.f-e";
  <<"!rm finalize.sh";
]


(*TODO: this is not the final version! \[Rule] more generalization needed!*)
WriteSpinCorrelatedMatrixElement[name_String,ampmunu_,abbr_List,indices_List,functions_List,nlegs_Integer,spinleg_Integer]:=Block[
  {strm,defvars,i,Sfe6,Sfe6c,vars,ulist},

  Clear[FormAddTAG,FormAddAmpOut,FormAddAmpMuNuOut,FormAddDefInd,FormAddDefVarsOut,FormAddVarsSfe6,FormAddUlistSfe6,
        FormAddVarsSfe6c,FormAddUlistSfe6c,FormAddVarsSfe6Sfe6c,FormAddUlistSfe6Sfe6c,FormAddVars0,FormAddUlist0];

  If[spinleg>nlegs,Print["Error: spinleg > nlegs."];Exit[];];

  (*generate fortran code*)
  strm = OpenFortran[name<>".mf"];
  WriteStringn[strm, "subroutine "<>name<>"(p,ampmunu)"];
  WriteStringn[strm, "implicit none"];
  WriteStringn[strm, "#include \"PhysPars.h\""];
  WriteStringn[strm, "#include \"pwhg_math.h\""];
  WriteStringn[strm, "double precision p(0:3,"<>ToString[nlegs]<>")"];
  WriteStringn[strm, "double precision al(0:3), be(0:3)"];
  WriteStringn[strm, "integer alind, beind"];
  WriteStringn[strm, "double precision ampmunu(0:3,0:3,"<>ToString[nlegs]<>")"];
  For[i=1,i<=nlegs,i++,
    WriteStringn[strm, "double precision k"<>ToString[i]<>"(0:3)"];
  ];
  If[nlegs==4,
    WriteStringn[strm, "double precision S, T, U"];
  ];
  If[nlegs==5,
    WriteStringn[strm, "double precision S, T, U, S34, T14, T24"];
  ];

  FormAddDefInd = Join[GetVariables[indices],{FormAddTAG}];
  WriteStringn[strm, "integer <* FormAddDefInd *>"];

  (*define functions*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "double precision Epsilon, DotP, Den"];
  WriteStringn[strm, "double precision momsq, momsum2sq, momsum3sq"];
  WriteStringn[strm, "external Epsilon, DotP, Den"];
  WriteStringn[strm, "external momsq, momsum2sq, momsum3sq"];

  (*define local variables*)
  WriteStringn[strm, ""];
  defvars=Map[Join[#,{FormAddTAG}]&,Subsetn[GetVariables[abbr]/.indices,4]];
  For[i=1,i<=Length[defvars],i++,
    FormAddDefVarsOut[i]=defvars[[i]];
    WriteStringn[strm, "double precision <* FormAddDefVarsOut["<>ToString[i]<>"] *>"];
  ];

  (*reset*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "ampmunu(:,:,:) = 0D0"];

  (*Momenta and Mandelstams*)
  WriteStringn[strm, ""];
  For[i=1,i<=nlegs,i++,
    WriteStringn[strm, "k"<>ToString[i]<>"(:) = p(:,"<>ToString[i]<>")"];
  ];
  WriteStringn[strm, "S   = momsum2sq(k1(:), k2(:))"];
  WriteStringn[strm, "T   = momsum2sq(k1(:),-k3(:))"];
  WriteStringn[strm, "U   = momsum2sq(k2(:),-k3(:))"];
  If[nlegs==5,
    WriteStringn[strm, "S34 = momsum2sq(k3(:), k4(:))"];
    WriteStringn[strm, "T14 = momsum2sq(k1(:),-k4(:))"];
    WriteStringn[strm, "T24 = momsum2sq(k2(:),-k3(:))"];
  ];

  (*loop over al and be*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "do alind=0,3"];
  WriteStringn[strm, "do beind=0,3"];
  WriteStringn[strm, ""];
  WriteStringn[strm, "al(:) = 0D0"];
  WriteStringn[strm, "al(alind) = 1D0"];
  WriteStringn[strm, "be(:) = 0D0"];
  WriteStringn[strm, "be(beind) = 1D0"];

  (*calculate abbreviations*)
  vars=GetVariables[abbr];
  ulist=Map[UniqueName,vars];

  FormAddVarsSfe6=GetElementsWithArgs[vars,Sfe6];
  FormAddUlistSfe6=GetElementsWithArgs[ulist,Sfe6];
  FormAddVarsSfe6c=GetElementsWithArgs[vars,Sfe6c];
  FormAddUlistSfe6c=GetElementsWithArgs[ulist,Sfe6c];
  FormAddVarsSfe6Sfe6c=GetElementsWithArgs[vars,Sfe6,Sfe6c];
  FormAddUlistSfe6Sfe6c=GetElementsWithArgs[ulist,Sfe6,Sfe6c];
  FormAddVars0=GetElementsWithoutArgs[vars,Sfe6c,Sfe6];
  FormAddUlist0=GetElementsWithoutArgs[ulist,Sfe6c,Sfe6];

  WriteStringn[strm, ""];
  MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVars0,FormAddUlist0}];

  If[Length[FormAddVarsSfe6]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6,FormAddUlistSfe6}];
    WriteStringn[strm, "enddo"];
  ];

  If[Length[FormAddVarsSfe6c]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6c=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6c,FormAddUlistSfe6c}];
    WriteStringn[strm, "enddo"];
  ];

  If[Length[FormAddVarsSfe6Sfe6c]!=0,
    WriteStringn[strm, ""];
    WriteStringn[strm, "do Sfe6=1,2"];
    WriteStringn[strm, "do Sfe6c=1,2"];
    MapThread[  WriteStringn[strm, "      <* "<>ToString[#1]<>" *> = <* "<>ToString[#2]<>" *>" ]&,{FormAddVarsSfe6Sfe6c,FormAddUlistSfe6Sfe6c}];
    WriteStringn[strm, "enddo"];
    WriteStringn[strm, "enddo"];
  ];

  (*write Matrix element*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "ampmunu(alind,beind,"<>ToString[spinleg]<>") = <* FormAddAmpMuNuOut *>"];

  (*end loop over al and be*)
  WriteStringn[strm, ""];
  WriteStringn[strm, "enddo"];
  WriteStringn[strm, "enddo"];

  WriteStringn[strm, ""];
  WriteStringn[strm, "end"];
  Close[strm];

  (*substitute wildcards*)
  AssignValues[ulist,GetValues[abbr]/.functions];
  FormAddAmpMuNuOut=ampmunu/.functions;
  (*FileTemplateApply[FileTemplate[ame<>".mf"],name<>".f"]*)
  Splice[name<>".mf", PageWidth -> 72];

  (*finalize the output, remove the Function "List(...)" that is wrapped around the variables*)
  strm = OpenWrite["finalize.sh"];
  WriteStringn[strm, "#!/bin/bash"];
  WriteStringn[strm, "gsed -i -e s/List\(//g "<>name<>".f"];
  WriteStringn[strm, "gsed -i -e s/,FormAddTAG\)//g "<>name<>".f"];
  WriteStringn[strm, "gsed -i -e 's/\\t/      /g' "<>name<>".f"];
  WriteStringn[strm, "mv "<>name<>".f "<>name<>".F"];
  Close[strm];
  <<"!chmod +x finalize.sh";
  <<"!./finalize.sh";
  <<"!rm *.f-e";
  <<"!rm finalize.sh";
]


(*Function to get the coefficient of an factorial expression*)
Clear[DCHelper1,DCHelper,DenCoefficient]
DCHelper1[expr_,denom_]:=
Module[{f},f/;
NumericQ[Denominator[f=Simplify[expr*denom]]]
&&Not[NumericQ[Denominator[expr]]]
&&NumericQ[Simplify[Denominator[Simplify[f/denom]]/denom]]]
DCHelper1[expr_,denom_]:=
Module[{f},0/;
Not[NumericQ[Denominator[Simplify[f=expr*denom]]]]
||NumericQ[Denominator[expr]]
||Not[NumericQ[Simplify[Denominator[Simplify[f/denom]]/denom]]]]
DCHelper[expr_,denom_]:=
Module[{hold},FullSimplify[Plus@@(DCHelper1[#,denom]&/@(List@@(Expand[expr]+hold)))]/.hold->0]
DenCoefficient[expr_,denom_]:=DCHelper[FullSimplify[DCHelper[expr,denom]/denom],denom]
(*
(*Test*)
DenCoefficient[a/(2(a+b^2)),(a+b^2)]
DenCoefficient[a/(2(a+b^2)),(a+b)]
DenCoefficient[a,(a+b)]
DenCoefficient[a/(a+b),(a+b)^2]
DenCoefficient[a/(a+b)^2,(a+b)^2]
DenCoefficient[a/(a+b)^2+a/(a+b)+(a+b)^2/2+b^2/(a^2+2a b+b^2),(a+b)^2]
(*should give 0:*)
DenCoefficient[a^2/(a+b)^4+2a b/(a+b)^4+b^2/(a+b)^4,(a+b)^4]
DenCoefficient[a^2/(a+b)^4+2a b/(a+b)^4+b^2/(a+b)^4,(a+b)^4]
DenCoefficient[a^4/(a+b)^4+(4*a^3*b)/(a+b)^4+(6*a^2*b^2)/(a+b)^4+(4*a*b^3)/(a+b)^4+b^4/(a+b)^4,(a+b)^4]
*)


End[]
EndPackage[]
