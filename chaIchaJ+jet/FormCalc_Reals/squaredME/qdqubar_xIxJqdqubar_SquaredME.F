*#define CHECK

#if 0
* qdqubar_xIxJqdqubar_SquaredME.F
* assembly of squared matrix element
* generated by FormCalc 9.4 (7 Jun 2016) on 23-Oct-2017 11:05
#endif

#include "qdqubar_xIxJqdqubar_vars.h"
#include "real_inline.h"
#include "real_contains.h"


************************************************************************

        subroutine qdqubar_xIxJqdqubar_SquaredMEHel(HelInd(vmax,res), flags)
        implicit none
        SIMD_ONLY(integer vmax)
        ResType res(HelDim(*))
        integer flags

#include "qdqubar_xIxJqdqubar_vars.h"

        HelType amp
        ResType ampsq
        integer iSUN, jSUN
#if DEBUG >= 3
        SIMD_ONLY(integer v)
#endif

* BEGIN ABBR_HEL
        call qdqubar_xIxJqdqubar_abbr0h
* END ABBR_HEL

        ampsq = 0
* BEGIN FF_TREE
        LOOP(jSUN, 1,2,1)
        Ctree(HelAll(jSUN)) = 0
        ENDLOOP(jSUN)

        call qdqubar_xIxJqdqubar_real

        LOOP(Sfe7, 1,2,1)
        call qdqubar_xIxJqdqubar_real_Sfe7
        ENDLOOP(Sfe7)

        LOOP(Sfe8, 1,2,1)
        LOOP(Sfe7, 1,2,1)
        call qdqubar_xIxJqdqubar_real_Sfe7_Sfe8
        ENDLOOP(Sfe7)
        ENDLOOP(Sfe8)
* END FF_TREE

* BEGIN M2_TREE
        LOOP(jSUN, 1,2,1)
        amp = 0
        LOOP(iSUN, 1,2,1)
        amp = amp + Ctree(HelAll(iSUN))*MatSUN(iSUN,jSUN)
        ENDLOOP(iSUN)
        ampsq = ampsq + Re(amp*Conjugate(Ctree(HelAll(jSUN))))
        ENDLOOP(jSUN)
* END M2_TREE
        res(HelAll(1)) = ampsq

        ampsq = 0
        res(HelAll(2)) = ampsq

#if DEBUG >= 3
        print 1, HelLoop(Hel(HelInd(v,1:LEGS)), res(HelInd(v,1:2)), v,vmax)
1        format(' sqme(', LEGS I3, ') =', 2F25.12)
#endif
        end

************************************************************************

        subroutine qdqubar_xIxJqdqubar_SquaredME(result, helicities, flags)
        implicit none
        RealType result(*)
        integer*8 helicities
        integer flags

#include "qdqubar_xIxJqdqubar_vars.h"
#include "qdqubar_xIxJqdqubar_specs.h"

* BEGIN VAR_DECL
        integer*8 hbits, hlast
        integer seq(2)
        save hlast, seq
        integer i, h, hmax
        parameter (hmax = 64)
        SIMD_ONLY(integer v)
        integer hsimd
        parameter (hsimd = SIMD_CEIL(hmax))
        ResType res(HelDim(2),hsimd)
        RealType rtree, rloop
        external qdqubar_xIxJqdqubar_SquaredMEHel
* END VAR_DECL

* BEGIN HSEL_DECL
        RealType norm
        RealType hseltest(0:hmax-1)
        ResType hseltest_v(HelDim(hsimd))
        equivalence (hseltest_v, hseltest)
        RealType hselmin
        integer hseli
        save hseltest, hselmin, hseli
* END HSEL_DECL

        data MatSUN /NaN(4)/
* -------- MK: added -----------------------------------------------------------
#include "skiphel_vars.h"
* -------- MK: added -----------------------------------------------------------

#include "real_inline.h"

* BEGIN SETMASS
        TEST(flags, BIT_SETMASS)
        result(1) = Mf(4,Gen(1))
        result(2) = Mf(3,Gen(2))
        result(3) = MCha(Cha(3))
        result(4) = MCha(Cha(4))
        result(5) = Mf(4,Gen(5))
        result(6) = Mf(3,Gen(6))
        return
        ENDTEST(flags, BIT_SETMASS)
* END SETMASS

* BEGIN INVARIANTS
        S = SInvariant(1,2)
        T = TInvariant(1,3)
        T14 = TInvariant(1,4)
        T15 = TInvariant(1,5)
        U = TInvariant(2,3)
        T24 = TInvariant(2,4)
        T25 = TInvariant(2,5)
        S34 = SInvariant(3,4)
        S35 = SInvariant(3,5)
        S45 = SInvariant(4,5)
* END INVARIANTS

        CHK_INI(seq)

        TEST(flags, BIT_RESET)
        hlast = 0
        seq(1) = seq(1) + 1
        INI_S()
* BEGIN ABBR_S
        call qdqubar_xIxJqdqubar_abbr0s
* END ABBR_S
        ENDTEST(flags, BIT_RESET)

        seq(2) = seq(2) + 1
        INI_A()
* BEGIN ABBR_ANGLE
        call qdqubar_xIxJqdqubar_abbr0a
* END ABBR_ANGLE

* BEGIN HEL_LOOP
        SIMD_ONLY(v = 1)
        h = 0

        do i = 0, hmax - 1
* BEGIN HSEL_IF
          if( hseltest(i) .lt. hselmin ) cycle
* END HSEL_IF

#define hval(s,m,a,b) a*mod(i/s,m)-b

          Hel0(1) = hval(32,2,2,1)
          Hel0(2) = hval(16,2,2,1)
          Hel0(3) = hval(8,2,2,1)
          Hel0(4) = hval(4,2,2,1)
          Hel0(5) = hval(2,2,2,1)
          Hel0(6) = hval(1,2,2,1)
          hbits = Generic(ARG_HEL,JOIN_HEL)
          if( iand(helicities, hbits) .ne. hbits ) cycle
#if DEBUG >= 1
          if( helicities .ne. hlast ) print 1, ' helicities: ', Hel0
#endif
          SIMD_ONLY(call VecCopy(v, LEGS))
          SIMD_ONLY(v = mod(v, SIMD) + 1)
          SIMD_ONLY(if( v .eq. 1 ) then)
          h = h + 1
          
* -------- MK: added -----------------------------------------------------------
#if NSKIP > 0
          if(.not.skiphel(h)) then
            call qdqubar_xIxJqdqubar_SquaredMEHel(HelInd(SIMD,res(HelAll(1),h)), flags)
          else
            res(HelAll(1),h) = 0D0
#if DEBUG >= 1
            print*,"skipping helicity ",h
#endif
          endif
          ! determine which hel-amplitudes to skip during the initialisation phase
          if(initskip) then
            if(res(HelAll(1),h).eq.0D0) mskip(h) = mskip(h) + 1
            if(mskip(h).ge.NSKIP) skiphel(h) = .true.
            if(minit.ge.ninit) initskip = .false.
            minit = minit + 1
          endif
#else
          call qdqubar_xIxJqdqubar_SquaredMEHel(HelInd(SIMD,res(HelAll(1),h)), flags)
#endif
#if DEBUG >= 2
          print*,h,res(HelAll(1),h)
#endif
* -------- MK: added -----------------------------------------------------------

          SIMD_ONLY(endif)
        enddo

        SIMD_ONLY(if( v .ne. 1 ) then)
        SIMD_ONLY(h = h + 1)
        SIMD_ONLY(call qdqubar_xIxJqdqubar_SquaredMEHel(HelInd(v,res(HelAll(1),h)), flags))
        SIMD_ONLY(endif)
        DEINI()
        SIMD_ONLY(if( v .ne. 1 ) res(v:SIMD,:,h) = 0)
* END HEL_LOOP

* BEGIN RESULT
        rtree = 0
        rloop = 0
        do i = 1, h
          rtree = rtree + HelSum(res(HelAll(1),i))
          rloop = rloop + HelSum(res(HelAll(2),i))
        enddo
        result(1) = rtree
        TEST(flags, BIT_LOOP)
#ifdef WF_RENORMALIZATION
        rloop = rloop + (WF_RENORMALIZATION)*rtree
#endif
        result(2) = rloop
        ENDTEST(flags, BIT_LOOP)

#if DEBUG >= 2
        print *, PROCNAME, ' =', rtree, rloop
#endif
* END RESULT

* BEGIN HSEL_SET
        if( helicities .ne. hlast ) then
          hseltest = 0
          hselmin = 0
          hseli = 0
        endif
        if( hseli .lt. hseln ) then
          norm = 1/(rtree + rloop)
          do i = 1, hsimd
            hseltest_v(HelAll(i)) = hseltest_v(HelAll(i)) +
     &        abs(norm*(res(HelAll(1),i) + res(HelAll(2),i)))
          enddo
          hseli = hseli + 1
          if( hseli .eq. hseln ) then
            hselmin = 0
            do i = 0, hmax - 1
              hselmin = max(hselmin, hseltest(i))
            enddo
            hselmin = hselmin*hseleps
            do i = 0, hmax - 1
              if( hseltest(i) .ge. hselmin ) cycle
              Hel0(1) = hval(32,2,2,1)
              Hel0(2) = hval(16,2,2,1)
              Hel0(3) = hval(8,2,2,1)
              Hel0(4) = hval(4,2,2,1)
              Hel0(5) = hval(2,2,2,1)
              Hel0(6) = hval(1,2,2,1)
              print 1, ' neglecting ', Hel0
1              format(A, LEGS I3)
            enddo
          endif
        endif
* END HSEL_SET

#ifdef CHECK
        print *, 'S =', S
        print *, 'T =', T
        print *, 'T14 =', T14
        print *, 'T15 =', T15
        print *, 'U =', U
        print *, 'T24 =', T24
        print *, 'T25 =', T25
        print *, 'S34 =', S34
        print *, 'S35 =', S35
        print *, 'S45 =', S45
        print *, 'tree =', rtree
        print *, 'loop =', rloop
        stop
#endif

        hlast = helicities

#include "real_contains.h"

        end

