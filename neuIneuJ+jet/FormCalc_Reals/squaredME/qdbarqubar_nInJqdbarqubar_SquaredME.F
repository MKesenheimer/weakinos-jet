*#define CHECK

#if 0
* qdbarqubar_nInJqdbarqubar_SquaredME.F
* assembly of squared matrix element
* generated by FormCalc 8.4 on 29-Jul-2016 8:49
#endif

#include "qdbarqubar_nInJqdbarqubar_vars.h"
#include "contains.h"


************************************************************************

        subroutine qdbarqubar_nInJqdbarqubar_SquaredMEHel(res, flags)
        implicit none
        ResType res(HelDim(*))
        integer flags

#include "qdbarqubar_nInJqdbarqubar_vars.h"

        HelType amp
        ResType ampsq
        integer iSUN, jSUN

* BEGIN ABBR_HEL
        call qdbarqubar_nInJqdbarqubar_abbr0h
* END ABBR_HEL

        ampsq = 0
* BEGIN FF_TREE
        LOOP(jSUN, 1,2,1)
        Ctree(HelInd(jSUN)) = 0
        ENDLOOP(jSUN)

        call qdbarqubar_nInJqdbarqubar_real

        LOOP(Sfe7, 1,2,1)
        call qdbarqubar_nInJqdbarqubar_real_Sfe7
        ENDLOOP(Sfe7)

        LOOP(Sfe8, 1,2,1)
        LOOP(Sfe7, 1,2,1)
        call qdbarqubar_nInJqdbarqubar_real_Sfe7_Sfe8
        ENDLOOP(Sfe7)
        ENDLOOP(Sfe8)
* END FF_TREE

* BEGIN M2_TREE
        LOOP(jSUN, 1,2,1)
        amp = 0
        LOOP(iSUN, 1,2,1)
        amp = amp + MatSUN(iSUN,jSUN)*Ctree(HelInd(iSUN))
        ENDLOOP(iSUN)
        ampsq = ampsq + Re(Conjugate(Ctree(HelInd(jSUN)))*amp)
        ENDLOOP(jSUN)
* END M2_TREE
        res(HelInd(1)) = ampsq

        ampsq = 0
        res(HelInd(2)) = ampsq
        end

************************************************************************

        subroutine qdbarqubar_nInJqdbarqubar_SquaredME(result, helicities, flags)
        implicit none
        RealType result(*)
        integer*8 helicities
        integer flags

#include "qdbarqubar_nInJqdbarqubar_vars.h"

* BEGIN VAR_DECL
        SIMD_ONLY(integer v)
        integer i, h, hmax, hsimd
        parameter (hmax = 64)
        parameter (hsimd = SIMD_CEIL(hmax))
        integer*8 hbits
        ResType res(HelDim(2),hsimd)
        RealType rtree, rloop
        external qdbarqubar_nInJqdbarqubar_SquaredMEHel
* END VAR_DECL

* BEGIN HSEL_DECL
        RealType norm
        ResType hseltest_v(HelDim(hsimd))
        RealType hseltest_s(0:hmax-1)
        equivalence (hseltest_v, hseltest_s)
        RealType hselmin
        integer hseli
        save hseltest_v, hselmin, hseli
* END HSEL_DECL

        data MatSUN /4*bogus/


        PAR_PREP(res,res(HelInd(1),2), Sub11,ends, Opt1,enda, seq,endhel)

* BEGIN INVARIANTS
        S = SInvariant(1,2)
        T = TInvariant(1,3)
        T14 = TInvariant(1,4)
        T15 = TInvariant(1,5)
        U = TInvariant(2,3)
        T24 = TInvariant(2,4)
        T25 = TInvariant(2,5)
        S34 = SInvariant(3,4)
        S35 = SInvariant(3,5)
        S45 = SInvariant(4,5)
* END INVARIANTS

        TEST(flags, BIT_RESET)
* BEGIN ABBR_S
        seq(1) = seq(1) + 1
        INI_S(seq)
        call qdbarqubar_nInJqdbarqubar_abbr0s
* END ABBR_S
        ENDTEST(flags, BIT_RESET)

* BEGIN ABBR_ANGLE
        seq(2) = seq(2) + 1
        INI_ANGLE(seq)
        call qdbarqubar_nInJqdbarqubar_abbr0a
* END ABBR_ANGLE

* BEGIN HEL_LOOP
        SIMD_ONLY(v = 1)
        h = 0

        do i = 0, hmax - 1
* BEGIN HSEL_IF
          if( hseltest_s(i) .lt. hselmin ) cycle
* END HSEL_IF

          Hel(1) = -1 + 2*Mod(i/32,2)
          Hel(2) = -1 + 2*Mod(i/16,2)
          Hel(3) = -1 + 2*Mod(i/8,2)
          Hel(4) = -1 + 2*Mod(i/4,2)
          Hel(5) = -1 + 2*Mod(i/2,2)
          Hel(6) = -1 + 2*Mod(i/1,2)
          hbits =
     &      + MASK_HEL(1)
     &      + MASK_HEL(2)
     &      + MASK_HEL(3)
     &      + MASK_HEL(4)
     &      + MASK_HEL(5)
     &      + MASK_HEL(6)
          if( iand(helicities, hbits) .ne. hbits ) cycle

          SIMD_ONLY(call VecCopy(v, LEGS, Hel(1)))
          SIMD_MULT(v = mod(v, SIMD) + 1)
          SIMD_MULT(if( v .eq. 1 ) then)
          h = h + 1
          PAR_EXEC(qdbarqubar_nInJqdbarqubar_SquaredMEHel, res(HelInd(1),h), flags)
          SIMD_MULT(endif)
        enddo

        SIMD_MULT(if( v .ne. 1 ) then)
        SIMD_MULT(h = h + 1)
        SIMD_MULT(PAR_EXEC(qdbarqubar_nInJqdbarqubar_SquaredMEHel, res(HelInd(1),h), flags))
        SIMD_MULT(endif)
* END HEL_LOOP

        PAR_SYNC()
        DEINI(seq)

        SIMD_MULT(if( v .ne. 1 ) res(v:SIMD,:,h) = 0)
* BEGIN RESULT
        rtree = 0
        rloop = 0
        do i = 1, h
          rtree = rtree + HelSum(res(HelInd(1),i))
          rloop = rloop + HelSum(res(HelInd(2),i))
        enddo
        result(1) = rtree
        TEST(flags, BIT_LOOP)
#ifdef WF_RENORMALIZATION
        rloop = rloop + (WF_RENORMALIZATION)*rtree
#endif
        result(2) = rloop
        ENDTEST(flags, BIT_LOOP)
* END RESULT

* BEGIN HSEL_SET
        if( hseli .lt. hseln ) then
          norm = 1/(rtree + rloop)
          do i = 1, hsimd
            hseltest_v(HelInd(i)) = hseltest_v(HelInd(i)) +
     &        abs(norm*(res(HelInd(1),i) + res(HelInd(2),i)))
          enddo
          hseli = hseli + 1
          if( hseli .eq. hseln ) then
            hselmin = 0
            do i = 0, hmax - 1
              hselmin = max(hselmin, hseltest_s(i))
            enddo
            hselmin = hselmin*hseleps
            do i = 0, hmax - 1
              if( hseltest_s(i) .ge. hselmin ) cycle
              Hel(1) = -1 + 2*Mod(i/32,2)
              Hel(2) = -1 + 2*Mod(i/16,2)
              Hel(3) = -1 + 2*Mod(i/8,2)
              Hel(4) = -1 + 2*Mod(i/4,2)
              Hel(5) = -1 + 2*Mod(i/2,2)
              Hel(6) = -1 + 2*Mod(i/1,2)
              print 123, Hel
123              format(' neglecting ', LEGS I3)
            enddo
          endif
        endif
* END HSEL_SET

#ifdef CHECK
        print *, 'S =', S
        print *, 'T =', T
        print *, 'T14 =', T14
        print *, 'T15 =', T15
        print *, 'U =', U
        print *, 'T24 =', T24
        print *, 'T25 =', T25
        print *, 'S34 =', S34
        print *, 'S35 =', S35
        print *, 'S45 =', S45
        print *, 'tree =', rtree
        print *, 'loop =', rloop
        stop
#endif

#include "contains.h"
* END SQUAREDME
        end

